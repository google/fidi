// fidi_flex_lexer.h ---  -*- mode: c++; -*-

// Copyright 2018-2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// \file
/// \ingroup inputhandling
///
/// This file contains the implementation of the scanner class, which
/// is derived from the builtin yyFlexLexer class, and used to define
/// our constructors and the ‘yylex’ function.

// Code:

#ifndef FIDI_FLEX_LEXER_H
#  define FIDI_FLEX_LEXER_H

#  if !defined(yyFlexLexerOnce)
#    include <FlexLexer.h>
#  endif

#  include "src/config.h"
#  include "src/fidi_parser.hh"

/// \brief All fidi (φίδι) code lives in the fidi namespace
///
/// This way we do not pollute other namespaces.
namespace fidi {

  /// \brief A subclass of yyFlexLexer implementing the scanner
  ///
  /// This class mostly exists to store the location information and
  /// create out own yylex declaration (which we define in the \ref
  /// YY_DECL macro to pass in the location information ), The YY_DECL
  /// macro is used by the generated scanner to implement the yylex
  /// function. See fidi_scanner.ll for details on how the location is
  /// updated in user actions.
  class FidiFlexLexer : public yyFlexLexer {
   public:
    /// \brief Construct a scanner given an input stream to parse
    ///
    /// The driver is responsible for creating the std::isttram with
    /// the content to be parsed. The initial location is set to the
    /// NULL pointer.
    ///
    /// \param[in] in A pointer to a stream containing content to be parsed
    FidiFlexLexer(std::istream *in) : yyFlexLexer(in){};

    /// The copy constructor is unused, and cleaned up.
    FidiFlexLexer(const fidi::FidiFlexLexer &) = delete;

    /// The assignment operator as well is cleaned up s it is not used.
    FidiFlexLexer &operator=(const fidi::FidiFlexLexer &) = delete;

    /// The move operations are unused, and cleaned up.
    ///
    /// The move operators are implicitly disabled, since there are no
    /// declarations and the compiler will not provide a version since we are
    /// defining copy constructors above. However, cleaning up explicitly also
    /// prevents derived classes from implementing the move operations. This is
    /// not a problem currently, since these are not needed, and removing them
    /// simplifies the generated code, and reduces its size.
    FidiFlexLexer(fidi::FidiFlexLexer &&) = delete;
    FidiFlexLexer &operator=(fidi::FidiFlexLexer &&) = delete;

    /// struct variant cleans up itself, and that is the only member we have
    virtual ~FidiFlexLexer(){};

    // get rid of override virtual function warning
    using FlexLexer::yylex;

    /// \brief The main scanning function
    ///
    /// The actual function body is generated by flex, based on the
    /// configuration parameters in src/fidi_scanner.ll. This
    /// declaration is replicated in the YY_DECL macro defined in
    /// fidi_scanner.ll to facilitate doing so. The method body
    /// created by flex in fidi_scanner.cc The YY_USER_ACTION macro
    /// updates the location after the next token is scanned.
    ///
    /// \param[in,out] lval The semantic token, of type struct variant
    /// \param[in,out] location The location in the stream being scanned
    /// \return int Indicates if the action was successful.
    virtual int yylex(fidi::Parser::semantic_type *const lval,
                      fidi::Parser::location_type *      location);

    /// \brief Count bracket nesting in the payload
    ///
    /// A request payload starts and ends with a square
    /// bracket. However, they payload is a full request to the next
    /// fidi (φίδι) instance, and potentially itself contains further
    /// outgoing calls and their payloads, so we need to ensure that
    /// we do not end scanning the payload too early. This counter
    /// keeps track of payload nesting in the request, incremented
    /// with each payload start, and decremented at a payload end.
    int bracket_count = 0;

   private:
    /* yyval ptr */
    fidi::Parser::semantic_type *yylval =
        nullptr;  ///< Pointer to the current token
  };

} /* end namespace fidi*/

#endif /* FIDI_FLEX_LEXER_H */

//
// fidi_flex_lexer.h ends here
